package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, PRINT, RETURN, VOID, CONST, BREAK, ELSE, IF, WHILE, NEW, READ, EXTENDS, CONTINUE, FINDANDREPLACE, FINDANY;
terminal LBRACE, RBRACE, SEMI, PLUS, MINUS, MUL, DIV, MOD, DOUBLEEQUAL, NOEQUAL, GREATER, GREQUAL, LESS, GRLESSER, AND, OR, DOUBLEMINUS;
terminal EQUAL, COLON, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, FOLLOWS, COMMA, DOUBLEPLUS, CLASS, FOREACH;

terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

nonterminal MethodDeclList, VarDecl, DeclList, VarDeclList, ConstDeclList, Brackets, BracketList, MethodDecl, ConstDecl;
nonterminal ConstLiteral, ConstLiteralList, MethOnce, FormsParams, FormPars, Statements, Statement; 
nonterminal DesignatorStatement, Condition, ExprBrackets, Designator, ElseBracket, Expr, NumConstBrack;
nonterminal AssList, Assignop, ActParams, ActPars, BracketMinus, Term, AddOpList, Factor, MulList;
nonterminal Mulop, Addop, ExprList, ParenActPars, ExpList, CondTerm, CondList;
nonterminal CondFact, FactList, RelBrackets, Relop, Label, NewBracketList, VarDeclL;
nonterminal VarDList;
precedence left ELSE;

Program ::= (Program) PROG ProgName:p DeclList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) IDENT:progName;

DeclList ::= (VarDeclarations) DeclList VarDeclList SEMI
	|
	(ConstDeclarations) DeclList ConstDeclList SEMI
	|
	(NoDeclList) /* epsilon */ 
	;

VarDeclList ::= (VarDeclaration) Type:varType VarDecl
			| (VarDeclarationComma) VarDeclList COMMA VarDecl
;
		
VarDecl ::= (VarDecl) IDENT:varName Brackets
;

Type ::= (Type) IDENT:typeName 
;

Brackets ::= (ArrayBrackets) LBRACKET RBRACKET /*Brackets*/
	|
	(NoBrackets) /* epsilon */
	;


				
ConstDeclList ::= (ConstDeclaration) CONST Type ConstDecl
		|
		(ConstDeclarationComma) ConstDeclList COMMA ConstDecl 
;

ConstDecl ::= (ConstDecl) IDENT EQUAL ConstLiteral
;


ConstLiteral ::= (ConstNumber) NUMBER
		|
		(ConstChar) CHAR
		|
		(ConstBool) BOOL
		;

MethodDeclList ::= (MethodDeclarationList) MethodDeclList MethodDecl
			|
			(NoMethodDeclList) /* epsilon */
			;

MethodDecl ::= (MethodDecl) MethOnce IDENT LPAREN FormsParams RPAREN VarDList LBRACE Statements RBRACE;

VarDList ::= (VarMethList) VarDList VarDeclL SEMI
			|
			(NoVarMethList) /*epsilon*/
;
VarDeclL ::= (VarMethodList) Type:varType VarDecl
			| 
			(VarMethodListComma) VarDeclL COMMA VarDecl 
			|
			(NoVarMethodList) /* epsilon*/
			;


MethOnce ::= (MethType) Type | (MethVoid) VOID ;



FormsParams ::= (FormsParameters) FormPars
		|
		(NoFormsParameters) /* epsilon */	
		;

FormPars ::= (FormParameter) Type IDENT Brackets
			|
			(FormParameterComma) FormPars COMMA Type IDENT Brackets 
;

Statements ::= (StatementList) Statements Statement
		|
		(NoStatements) /* epsilon */
		;

Statement ::= (DesigStatement) DesignatorStatement SEMI
			|
			(FindAnyStatement) Designator Assignop Designator DOT FINDANY LPAREN Expr RPAREN SEMI
			|
			(FindReplaceStatement) Designator Assignop Designator DOT FINDANDREPLACE LPAREN Expr COMMA IDENT FOLLOWS Expr RPAREN SEMI
			|
			(ForeachStatement) Designator DOT FOREACH LPAREN IDENT FOLLOWS Statement RPAREN SEMI
			|
			(IfStatement) IF LPAREN Condition RPAREN Statement ElseBracket
			|
			(WhileStatement) WHILE LPAREN Condition RPAREN Statement
			|
			(BreakStatement) BREAK SEMI
			|
			(ContinueStatement) CONTINUE SEMI
			|
			(ReturnStatement) RETURN ExprBrackets SEMI
			|
			(ReadStatement) READ LPAREN Designator RPAREN SEMI
			|
			(PrintStatement) PRINT LPAREN Expr NumConstBrack RPAREN SEMI
			|
			(BraceStatements) LBRACE Statements RBRACE
			
;

NumConstBrack ::= (NumConstAddition) COMMA NUMBER:numConst
		|
		(NoNumConstAddition) /* epsilon */
		;


ExprBrackets ::= (ExprBrack) Expr
		|
		(NoExprBrack) /* epsilon */
;

Expr ::= (ExprMinusBeggin) MINUS Term AddOpList
		| 
		(JustExpr) Term AddOpList
		;

Term ::= (Term) Factor MulList;



MulList ::= (MultiplicativeList) MulList Mulop Factor
	| (NoMultiplicativeList) /* epsilon */
;

Mulop ::= (OpMul) MUL | (OpDiv) DIV | (OpMod) MOD;

AddOpList ::= (PlusOpList) AddOpList PLUS Term
	|
	(MinusOpList) AddOpList MINUS Term
	|(NoAddOpList) /* epsilon */
	;

Factor ::= (FactorNumber) NUMBER
	| (FactorChar) CHAR
	| (FactorBool) BOOL
	| (FactorNewTypeOneBracket) NEW Type LBRACKET Expr RBRACKET
	| (FactorNewTypeTwoBracket) NEW Type LBRACKET Expr RBRACKET LBRACKET Expr RBRACKET
	| (FactorParenExpr) LPAREN Expr RPAREN
	| (FactorDesign) Designator ParenActPars
;


Designator ::= (DesignatorIdent) IDENT 
			| (DesignatorBracketExpr) Designator LBRACKET Expr RBRACKET
;

ParenActPars ::= (ParenActParams) LPAREN ActParams RPAREN //ActParams
		| (NoParenActParams) /* epsilon */
;

ActParams ::= (ActParmList) ActPars
	|
	(NoActParams) /* epsilon */
	;

ActPars ::= (ActParsExpr) Expr
		| (ActParsComma) ActPars COMMA Expr
;



DesignatorStatement ::= (DesignatorStatement) Designator AssList;

AssList ::= (AssListAssOpExpr) Assignop Expr 
	|
	(AssListActParams) LPAREN ActParams RPAREN 
	|
	(AssListDoublePlus) DOUBLEPLUS
	|
	(AssListDoubleMinus) DOUBLEMINUS
;

Assignop ::= (Assignop) EQUAL;


Condition ::= (ConditionJustTerm) CondTerm 
			| (ConditionOrTerm) Condition OR CondTerm;


CondTerm ::= (ConditionFact) CondFact 
			| (ConditionAndFact) CondTerm AND CondFact;


CondFact ::= (CondFact) Expr RelBrackets;

RelBrackets ::= (RelationBrackets) Relop Expr
	| (NoRelationBrackets) /* epsilon */
;

Relop ::= (RelDbEq) DOUBLEEQUAL | (RelNoEq) NOEQUAL | (RelGreater) GREATER | (RelGrEq) GREQUAL |(RelLess) LESS |(RelGrLesser) GRLESSER;

Label ::= (Label) IDENT;

ElseBracket ::= (ElseState) ELSE Statement
	| (NoElseStatement) /* epsilon */ 
;
