package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, PRINT, RETURN, VOID, CONST, BREAK, ELSE, IF, WHILE, NEW, READ, EXTENDS, CONTINUE, MAP;
terminal LBRACE, RBRACE, SEMI, PLUS, MINUS, MUL, DIV, MOD, DOUBLEEQUAL, NOEQUAL, GREATER, GREQUAL, LESS, GRLESSER, AND, OR, DOUBLEMINUS;
terminal EQUAL, COLON, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, FOLLOWS, COMMA, DOUBLEPLUS, CLASS;

terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;

nonterminal Program;

nonterminal MethodDeclList, VarDecl, DeclList, VarDeclList, ConstDeclList, Brackets, BracketList, Type, MethodDecl, ConstDecl;
nonterminal ConstLiteral, ConstLiteralList, MethOnce, FormsParams, FormPars, Statements, Statement; 
nonterminal DesignatorStatement, Condition, ExprBrackets, Designator, ElseBracket, Expr, NumConstBrack;
nonterminal AssList, Assignop, ActParams, ActPars, BracketMinus, Term, AddOpList, Factor, MulList;
nonterminal Mulop, Addop, ExprList, ParenActPars, ExpList, CondTerm, CondList;
nonterminal CondFact, FactList, RelBrackets, Relop, Label, NewBracketList, VarDeclL;
nonterminal VarDList;
precedence left ELSE;

Program ::= PROG IDENT DeclList LBRACE MethodDeclList RBRACE;

DeclList ::= DeclList VarDeclList SEMI
	|
	DeclList ConstDeclList SEMI
	|
	/* epsilon */ 
	;

VarDeclList ::= Type:varType VarDecl
			| VarDeclList COMMA VarDecl
;
		
VarDecl ::= IDENT Brackets
;

Type ::= IDENT:typeName 
;

Brackets ::= LBRACKET RBRACKET Brackets
	|
	/* epsilon */
	;


				
ConstDeclList ::= CONST Type ConstDecl
		|
		ConstDeclList COMMA ConstDecl 
;

ConstDecl ::=  IDENT EQUAL ConstLiteral
;


ConstLiteral ::= NUMBER
		|
		CHAR
		|
		BOOL
		;

MethodDeclList ::= MethodDeclList MethodDecl
			|
			/* epsilon */
			;

MethodDecl ::= MethOnce IDENT LPAREN FormsParams RPAREN VarDList LBRACE Statements RBRACE;

VarDList ::= VarDList VarDeclL SEMI
			|
			/*epsilon*/
;
VarDeclL ::= Type:varType VarDecl
			| VarDeclL COMMA VarDecl 
			|
			/* epsilon*/
			;


MethOnce ::= Type | VOID ;



FormsParams ::= FormPars
		|
		/* epsilon */	
		;

FormPars ::= Type IDENT Brackets
			|
			FormPars COMMA Type IDENT Brackets 
;

Statements ::= Statements Statement
		|
		/* epsilon */
		;

Statement ::= DesignatorStatement SEMI
			|
			Designator Assignop Designator DOT MAP LPAREN IDENT FOLLOWS Expr RPAREN SEMI
			|
			IF LPAREN Condition RPAREN Statement ElseBracket
			|
			WHILE LPAREN Condition RPAREN Statement
			|
			 BREAK SEMI
			|
			CONTINUE SEMI
			|
			RETURN ExprBrackets SEMI
			|
			READ LPAREN Designator RPAREN SEMI
			|
			PRINT LPAREN Expr NumConstBrack RPAREN SEMI
			|
			LBRACE Statements RBRACE
			
;

NumConstBrack ::= COMMA NUMBER:numConst
		|
		/* epsilon */
		;


ExprBrackets ::= Expr
		|
		/* epsilon */
;

Expr ::= MINUS Term AddOpList
		| 
		Term AddOpList
		;

Term ::= Factor MulList;



MulList ::= MulList Mulop Factor
	| /* epsilon */
;

Mulop ::= MUL | DIV | MOD;

AddOpList ::= AddOpList PLUS Term
	|
	AddOpList MINUS Term
	|/* epsilon */
	;

Factor ::=  NUMBER
	| CHAR
	|BOOL
	|NEW Type LBRACKET Expr RBRACKET
	|NEW Type LBRACKET Expr RBRACKET LBRACKET Expr RBRACKET
	| LPAREN Expr RPAREN
	|Designator ParenActPars
;


Designator ::= IDENT 
			| Designator LBRACKET Expr RBRACKET
;

ParenActPars ::= LPAREN ActParams RPAREN //ActParams
		| /* epsilon */
;

ActParams ::= ActPars
	|
	/* epsilon */
	;

ActPars ::= Expr
		| ActPars COMMA Expr
;



DesignatorStatement ::= Designator AssList;

AssList ::= Assignop Expr 
	|
	LPAREN ActParams RPAREN 
	|
	DOUBLEPLUS
	|
	DOUBLEMINUS
;

Assignop ::= EQUAL;


Condition ::= CondTerm 
			| Condition OR CondTerm;


CondTerm ::= CondFact 
			| CondTerm AND CondFact;


CondFact ::= Expr RelBrackets;

RelBrackets ::= Relop Expr
	| /* epsilon */
;

Relop ::= DOUBLEEQUAL | NOEQUAL | GREATER | GREQUAL | LESS | GRLESSER;

Label ::= IDENT;

ElseBracket ::= ELSE Statement
	| /* epsilon */ 
;
