package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, PRINT, RETURN, VOID, CONST, BREAK, ELSE, IF, WHILE, NEW, READ, EXTENDS, CONTINUE, FINDANDREPLACE, FINDANY;
terminal LBRACE, RBRACE, SEMI, PLUS, MINUS, MUL, DIV, MOD, DOUBLEEQUAL, NOEQUAL, GREATER, GREQUAL, LESS, GRLESSER, AND, OR, DOUBLEMINUS;
terminal EQUAL, COLON, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, FOLLOWS, COMMA, DOUBLEPLUS, CLASS, FOREACH;

terminal String IDENT;
terminal Integer NUMBER;
terminal Character CHAR;
terminal Boolean BOOL;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

nonterminal MethodDeclList MethodDeclList;
nonterminal VarDecl VarDecl;
nonterminal DeclList DeclList;
nonterminal VarDeclList VarDeclList;
nonterminal ConstDeclList ConstDeclList;
nonterminal Brackets Brackets;
nonterminal BracketList BracketList;
nonterminal MethodDecl MethodDecl;
nonterminal ConstDecl ConstDecl;
nonterminal ConstLiteral ConstLiteral;
nonterminal ConstLiteralList ConstLiteralList;
nonterminal MethOnce MethOnce;
nonterminal FormsParams FormsParams;
nonterminal FormPars FormPars;
nonterminal Statements Statements;
nonterminal Statement Statement; 
nonterminal DesignatorStatement DesignatorStatement;
nonterminal Condition Condition;
nonterminal ExprBrackets ExprBrackets;
nonterminal Designator Designator;
nonterminal ElseBracket ElseBracket;
nonterminal Expr Expr;
nonterminal NumConstBrack NumConstBrack;
nonterminal AssList AssList;
nonterminal Assignop Assignop;
nonterminal ActParams ActParams;
nonterminal ActPars ActPars;
nonterminal BracketMinus BracketMinus;
nonterminal Term Term;
nonterminal AddOpList AddOpList;
nonterminal Factor Factor;
nonterminal MulList MulList;
nonterminal Mulop Mulop;
nonterminal Addop Addop;
nonterminal ExprList ExprList;
nonterminal ParenActPars ParenActPars;
nonterminal ExpList ExpList;
nonterminal CondTerm CondTerm;
nonterminal CondList CondList;
nonterminal CondFact CondFact;
nonterminal FactList FactList;
nonterminal RelBrackets RelBrackets;
nonterminal Relop Relop;
nonterminal Label Label;
nonterminal NewBracketList NewBracketList;
nonterminal VarDeclL VarDeclL;
nonterminal VarDList VarDList;
precedence left ELSE;

Program ::= (Program) PROG ProgName:p DeclList:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(p, D1, M2); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

DeclList ::= (VarDeclarations) DeclList:D1 VarDeclList:V2 SEMI {: RESULT=new VarDeclarations(D1, V2); RESULT.setLine(D1left); :}
	|
	(ConstDeclarations) DeclList:D1 ConstDeclList:C2 SEMI {: RESULT=new ConstDeclarations(D1, C2); RESULT.setLine(D1left); :}
	|
	(NoDeclList) {: RESULT=new NoDeclList(); :} /* epsilon */ 
	;

VarDeclList ::= (VarDeclaration) Type:varType VarDecl:V1 {: RESULT=new VarDeclaration(varType, V1); RESULT.setLine(varTypeleft); :}
			| (VarDeclarationComma) VarDeclList:V1 COMMA VarDecl:V2 {: RESULT=new VarDeclarationComma(V1, V2); RESULT.setLine(V1left); :}
;
		
VarDecl ::= (VarDecl) IDENT:varName Brackets:B1 {: RESULT=new VarDecl(varName, B1); RESULT.setLine(varNameleft); :}
;

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :} 
;

Brackets ::= (ArrayBrackets) LBRACKET RBRACKET {: RESULT=new ArrayBrackets(); :} /*Brackets*/
	|
	(NoBrackets) {: RESULT=new NoBrackets(); :} /* epsilon */
	;


				
ConstDeclList ::= (ConstDeclaration) CONST Type:T1 ConstDecl:C2 {: RESULT=new ConstDeclaration(T1, C2); RESULT.setLine(T1left); :}
		|
		(ConstDeclarationComma) ConstDeclList:C1 COMMA ConstDecl:C2 {: RESULT=new ConstDeclarationComma(C1, C2); RESULT.setLine(C1left); :} 
;

ConstDecl ::= (ConstDecl) IDENT:I1 EQUAL ConstLiteral:C2 {: RESULT=new ConstDecl(I1, C2); RESULT.setLine(I1left); :}
;


ConstLiteral ::= (ConstNumber) NUMBER:N1 {: RESULT=new ConstNumber(N1); RESULT.setLine(N1left); :}
		|
		(ConstChar) CHAR:C1 {: RESULT=new ConstChar(C1); RESULT.setLine(C1left); :}
		|
		(ConstBool) BOOL:B1 {: RESULT=new ConstBool(B1); RESULT.setLine(B1left); :}
		;

MethodDeclList ::= (MethodDeclarationList) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarationList(M1, M2); RESULT.setLine(M1left); :}
			|
			(NoMethodDeclList) {: RESULT=new NoMethodDeclList(); :} /* epsilon */
			;

MethodDecl ::= (MethodDecl) MethOnce:M1 IDENT:I2 LPAREN FormsParams:F3 RPAREN VarDList:V4 LBRACE Statements:S5 RBRACE {: RESULT=new MethodDecl(M1, I2, F3, V4, S5); RESULT.setLine(M1left); :};

VarDList ::= (VarMethList) VarDList:V1 VarDeclL:V2 SEMI {: RESULT=new VarMethList(V1, V2); RESULT.setLine(V1left); :}
			|
			(NoVarMethList) {: RESULT=new NoVarMethList(); :} /*epsilon*/
;
VarDeclL ::= (VarMethodList) Type:varType VarDecl:V1 {: RESULT=new VarMethodList(varType, V1); RESULT.setLine(varTypeleft); :}
			| 
			(VarMethodListComma) VarDeclL:V1 COMMA VarDecl:V2 {: RESULT=new VarMethodListComma(V1, V2); RESULT.setLine(V1left); :} 
			|
			(NoVarMethodList) {: RESULT=new NoVarMethodList(); :} /* epsilon*/
			;


MethOnce ::= (MethType) Type:T1 {: RESULT=new MethType(T1); RESULT.setLine(T1left); :} | (MethVoid) VOID {: RESULT=new MethVoid(); :} ;



FormsParams ::= (FormsParameters) FormPars:F1 {: RESULT=new FormsParameters(F1); RESULT.setLine(F1left); :}
		|
		(NoFormsParameters) {: RESULT=new NoFormsParameters(); :} /* epsilon */	
		;

FormPars ::= (FormParameter) Type:T1 IDENT:I2 Brackets:B3 {: RESULT=new FormParameter(T1, I2, B3); RESULT.setLine(T1left); :}
			|
			(FormParameterComma) FormPars:F1 COMMA Type:T2 IDENT:I3 Brackets:B4 {: RESULT=new FormParameterComma(F1, T2, I3, B4); RESULT.setLine(F1left); :} 
;

Statements ::= (StatementList) Statements:S1 Statement:S2 {: RESULT=new StatementList(S1, S2); RESULT.setLine(S1left); :}
		|
		(NoStatements) {: RESULT=new NoStatements(); :} /* epsilon */
		;

Statement ::= (DesigStatement) DesignatorStatement:D1 SEMI {: RESULT=new DesigStatement(D1); RESULT.setLine(D1left); :}
			|
			(FindAnyStatement) Designator:D1 Assignop:A2 Designator:D3 DOT FINDANY LPAREN Expr:E4 RPAREN SEMI {: RESULT=new FindAnyStatement(D1, A2, D3, E4); RESULT.setLine(D1left); :}
			|
			(FindReplaceStatement) Designator:D1 Assignop:A2 Designator:D3 DOT FINDANDREPLACE LPAREN Expr:E4 COMMA IDENT:I5 FOLLOWS Expr:E6 RPAREN SEMI {: RESULT=new FindReplaceStatement(D1, A2, D3, E4, I5, E6); RESULT.setLine(D1left); :}
			|
			(ForeachStatement) Designator:D1 DOT FOREACH LPAREN IDENT:I2 FOLLOWS Statement:S3 RPAREN SEMI {: RESULT=new ForeachStatement(D1, I2, S3); RESULT.setLine(D1left); :}
			|
			(IfStatement) IF LPAREN Condition:C1 RPAREN Statement:S2 ElseBracket:E3 {: RESULT=new IfStatement(C1, S2, E3); RESULT.setLine(C1left); :}
			|
			(WhileStatement) WHILE LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new WhileStatement(C1, S2); RESULT.setLine(C1left); :}
			|
			(BreakStatement) BREAK SEMI {: RESULT=new BreakStatement(); :}
			|
			(ContinueStatement) CONTINUE SEMI {: RESULT=new ContinueStatement(); :}
			|
			(ReturnStatement) RETURN ExprBrackets:E1 SEMI {: RESULT=new ReturnStatement(E1); RESULT.setLine(E1left); :}
			|
			(ReadStatement) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
			|
			(PrintStatement) PRINT LPAREN Expr:E1 NumConstBrack:N2 RPAREN SEMI {: RESULT=new PrintStatement(E1, N2); RESULT.setLine(E1left); :}
			|
			(BraceStatements) LBRACE Statements:S1 RBRACE {: RESULT=new BraceStatements(S1); RESULT.setLine(S1left); :}
			
;

NumConstBrack ::= (NumConstAddition) COMMA NUMBER:numConst {: RESULT=new NumConstAddition(numConst); RESULT.setLine(numConstleft); :}
		|
		(NoNumConstAddition) {: RESULT=new NoNumConstAddition(); :} /* epsilon */
		;


ExprBrackets ::= (ExprBrack) Expr:E1 {: RESULT=new ExprBrack(E1); RESULT.setLine(E1left); :}
		|
		(NoExprBrack) {: RESULT=new NoExprBrack(); :} /* epsilon */
;

Expr ::= (ExprMinusBeggin) MINUS Term:T1 AddOpList:A2 {: RESULT=new ExprMinusBeggin(T1, A2); RESULT.setLine(T1left); :}
		| 
		(JustExpr) Term:T1 AddOpList:A2 {: RESULT=new JustExpr(T1, A2); RESULT.setLine(T1left); :}
		;

Term ::= (Term) Factor:F1 MulList:M2 {: RESULT=new Term(F1, M2); RESULT.setLine(F1left); :};



MulList ::= (MultiplicativeList) MulList:M1 Mulop:M2 Factor:F3 {: RESULT=new MultiplicativeList(M1, M2, F3); RESULT.setLine(M1left); :}
	| (NoMultiplicativeList) {: RESULT=new NoMultiplicativeList(); :} /* epsilon */
;

Mulop ::= (OpMul) MUL {: RESULT=new OpMul(); :} | (OpDiv) DIV {: RESULT=new OpDiv(); :} | (OpMod) MOD {: RESULT=new OpMod(); :};

AddOpList ::= (PlusOpList) AddOpList:A1 PLUS Term:T2 {: RESULT=new PlusOpList(A1, T2); RESULT.setLine(A1left); :}
	|
	(MinusOpList) AddOpList:A1 MINUS Term:T2 {: RESULT=new MinusOpList(A1, T2); RESULT.setLine(A1left); :}
	|(NoAddOpList) {: RESULT=new NoAddOpList(); :} /* epsilon */
	;

Factor ::= (FactorNumber) NUMBER:N1 {: RESULT=new FactorNumber(N1); RESULT.setLine(N1left); :}
	| (FactorChar) CHAR:C1 {: RESULT=new FactorChar(C1); RESULT.setLine(C1left); :}
	| (FactorBool) BOOL:B1 {: RESULT=new FactorBool(B1); RESULT.setLine(B1left); :}
	| (FactorNewTypeOneBracket) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new FactorNewTypeOneBracket(T1, E2); RESULT.setLine(T1left); :}
	| (FactorNewTypeTwoBracket) NEW Type:T1 LBRACKET Expr:E2 RBRACKET LBRACKET Expr:E3 RBRACKET {: RESULT=new FactorNewTypeTwoBracket(T1, E2, E3); RESULT.setLine(T1left); :}
	| (FactorParenExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactorParenExpr(E1); RESULT.setLine(E1left); :}
	| (FactorDesign) Designator:D1 ParenActPars:P2 {: RESULT=new FactorDesign(D1, P2); RESULT.setLine(D1left); :}
;


Designator ::= (DesignatorIdent) IDENT:I1 {: RESULT=new DesignatorIdent(I1); RESULT.setLine(I1left); :} 
			| (DesignatorBracketExpr) Designator:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorBracketExpr(D1, E2); RESULT.setLine(D1left); :}
;

ParenActPars ::= (ParenActParams) LPAREN ActParams:A1 RPAREN {: RESULT=new ParenActParams(A1); RESULT.setLine(A1left); :} //ActParams
		| (NoParenActParams) {: RESULT=new NoParenActParams(); :} /* epsilon */
;

ActParams ::= (ActParmList) ActPars:A1 {: RESULT=new ActParmList(A1); RESULT.setLine(A1left); :}
	|
	(NoActParams) {: RESULT=new NoActParams(); :} /* epsilon */
	;

ActPars ::= (ActParsExpr) Expr:E1 {: RESULT=new ActParsExpr(E1); RESULT.setLine(E1left); :}
		| (ActParsComma) ActPars:A1 COMMA Expr:E2 {: RESULT=new ActParsComma(A1, E2); RESULT.setLine(A1left); :}
;



DesignatorStatement ::= (DesignatorStatement) Designator:D1 AssList:A2 {: RESULT=new DesignatorStatement(D1, A2); RESULT.setLine(D1left); :};

AssList ::= (AssListAssOpExpr) Assignop:A1 Expr:E2 {: RESULT=new AssListAssOpExpr(A1, E2); RESULT.setLine(A1left); :} 
	|
	(AssListActParams) LPAREN ActParams:A1 RPAREN {: RESULT=new AssListActParams(A1); RESULT.setLine(A1left); :} 
	|
	(AssListDoublePlus) DOUBLEPLUS {: RESULT=new AssListDoublePlus(); :}
	|
	(AssListDoubleMinus) DOUBLEMINUS {: RESULT=new AssListDoubleMinus(); :}
;

Assignop ::= (Assignop) EQUAL {: RESULT=new Assignop(); :};


Condition ::= (ConditionJustTerm) CondTerm:C1 {: RESULT=new ConditionJustTerm(C1); RESULT.setLine(C1left); :} 
			| (ConditionOrTerm) Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionOrTerm(C1, C2); RESULT.setLine(C1left); :};


CondTerm ::= (ConditionFact) CondFact:C1 {: RESULT=new ConditionFact(C1); RESULT.setLine(C1left); :} 
			| (ConditionAndFact) CondTerm:C1 AND CondFact:C2 {: RESULT=new ConditionAndFact(C1, C2); RESULT.setLine(C1left); :};


CondFact ::= (CondFact) Expr:E1 RelBrackets:R2 {: RESULT=new CondFact(E1, R2); RESULT.setLine(E1left); :};

RelBrackets ::= (RelationBrackets) Relop:R1 Expr:E2 {: RESULT=new RelationBrackets(R1, E2); RESULT.setLine(R1left); :}
	| (NoRelationBrackets) {: RESULT=new NoRelationBrackets(); :} /* epsilon */
;

Relop ::= (RelDbEq) DOUBLEEQUAL {: RESULT=new RelDbEq(); :} | (RelNoEq) NOEQUAL {: RESULT=new RelNoEq(); :} | (RelGreater) GREATER {: RESULT=new RelGreater(); :} | (RelGrEq) GREQUAL {: RESULT=new RelGrEq(); :} |(RelLess) LESS {: RESULT=new RelLess(); :} |(RelGrLesser) GRLESSER {: RESULT=new RelGrLesser(); :};

Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};

ElseBracket ::= (ElseState) ELSE Statement:S1 {: RESULT=new ElseState(S1); RESULT.setLine(S1left); :}
	| (NoElseStatement) {: RESULT=new NoElseStatement(); :} /* epsilon */ 
;
